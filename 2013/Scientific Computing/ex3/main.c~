#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include"McGrath.h"

int main(void){
  // matrix convention: start from 1,1 (blanks in (0,j) and (i,0))
  double **ans;
  double *x, *y, *w, *S;
  int i,j,N;

  // TODO
  // - debug recursive call of SN - probably done now but needs checking. Works for N=4
  // - debug TN
  // - debug UN
  // - use SFactors to return values in base case, FastUN

  N=4;
  y = (double*)malloc((N-1)*sizeof(double));
  x = (double*)malloc((N-1)*sizeof(double));
  w = (double*)malloc(N*sizeof(double));
  S = (double*)malloc(N*sizeof(double));
  for(i=1;i<=N;i++){
    y[i] = i;
  }

  // testing code
  /*
  printf("Running SlowSN\n");
  SlowSN(x,y,w,S,N,1);
  printf("Running SlowTN\n");
  SlowTN(x,y,w,S,N,1);
  printf("Running SlowUN\n");
  SlowUN(x,y,w,S,N,1);
  */

  printf("running FastSN\n");
  FastSN(x,y,w,S,N,1);
  displayVector(x,N-1);

  printf("running SlowSN\n");
  for(i=1;i<=N;i++){
    x[i] = 0;
    y[i] = i;
  }
  SlowSN(x,y,w,S,N,1);
  // displayVector(x,N-1);

  return(0);
}

int FastSN(double *x, double *y, double *w, double *S, int N, int skip){
  int i,j;

  if(N==2){
    // the base case for recursion
    printf("Base case for FastSN\n");
    x[skip] = y[skip]; // should this be skip or 1?
    return(0);
  } else if(N%2==0) {
    // recursive block
    // store s and a in the work array
    for(i=1;i<(N/2);i+=2){
      w[i] = y[i] + y[N-i]; // s values
      printf("s value w[%d] = %lf\n", i, w[i]);
    }
    w[N-1] = y[N/2]; // central s value
    printf("w[%d] = %lf\n", N-1, w[N-1]);
    for(i=1;i<=N/2;i+=2){
      w[i+1] = y[i] - y[N-i]; // a values
      printf("a value w[%d] = %lf - %lf\n", i, y[i], y[N-i]);
    }
    // now call FastSN and FastTN recursively - need to ensure that the correct part of w is used!
    printf("FastSN calling FastSN with N = %d\n", N/2);
    FastSN(x,w,y,S,N/2,skip*2);
    printf("FastSN calling FastTN with N = %d\n", N/2);
    FastTN(x-skip,w-skip,y-skip,S,N/2,skip*2);
  } else {
    // this happens if we can go no further - our initial N was not a power of 2
    for(i=1;i<=N;i++){
      for(j=1;j<=N;j++){
	x[i*skip] = sin(i*j*M_PI/N)*y[j];
      }
    }
  }
}

int FastTN(double *x, double *y, double *w, double *S, int N, int skip){
  int i,j;
  if(N==2){
    // don't factor down any further - just do the multiplication
    printf("Base case for FastTN\n");
    x[skip] = 0.5*sqrt(2)*y[skip]+y[2*skip]; // should this be skip?
    x[2*skip] = 0.5*sqrt(2)*y[skip]-y[2*skip];
    return(0);
  } else if (N==1) {
    // the base case for recursion - this shouldn't happen with powers of 2
    x[skip] = y[1];
    return(0);
  } else if (N%2==0) {
    // the recursive case
    // do FastTN on the even numbers - note reversal of w & y
    printf("FastTN calling FastTN with N = %d\n", N/2);
    FastTN(x,w,y,S,N/2,skip*2);
    // do FastUN on the odd numbers - reversal of w & y here as well
    printf("FastTN calling FastUN with N = %d\n", N/2);
    FastUN(x-skip,w-skip,y-skip,S,N/2,skip*2);
    // add the z's back together from the work array
    for(i=1;i<=N/2;i++){
      x[i] = w[(2*i)-1] + w[2*i];
      x[N+1-i] = w[(2*i)-1] - w[2*i];
    }
  } else {
    // we can go no further - initial N was not a power of 2
    // just brute-force multiply
    SlowTN(x,y,w,S,N,skip);
  }
  return(0);
}

int FastUN(double *x, double *y, double *w, double *S, int N, int skip){
  int i,j;
  if(N==2){
    // don't factor down any further - multiply
    printf("Base case for FastUN\n");
    x[skip] = 0.5*(sqrt(2-sqrt(2)))*y[1] + 0.5*(sqrt(2+sqrt(2)))*y[2]; // should this be skip?
    x[2*skip] = 0.5*(sqrt(2+sqrt(2)))*y[1] - 0.5*sqrt(2-sqrt(2))*y[2];
    return(0);
  } else if (N==1) {
    // recursion base case
    x[skip] = 0.5*sqrt(2)*y[1];
    return(0);
  } else if (N%2==0) {
    // recursive case
    // preprocess to u and v - store in work array
    for(i=1;i<N/2;i+=2){
      w[i] = y[N+1-2*i]-y[N-2*i]; // store u in odd numbers
    }
    w[N/2] = y[1];

    for(i=2;i<N/2;i+=2){
      w[i] = y[2*i] + y[2*i+1]; // store v in even numbers
    }
    w[N] = y[N];
    // do FastTN on u and v for a and b
    printf("FastUN calling FastTN with N = %d\n", N/2);
    FastTN(x,w,y,S,N/2,skip*2);
    printf("FastUN calling FastTN with N = %d\n", N/2);
    FastTN(x-skip,w-skip,y-skip,S,N/2,skip*2);
    // reassemble into x
    for(i=1;i<N/2;i++){
      x[i*skip] = 1*w[i*skip] + 2*w[(i+1)*skip]; // change 1, 2 to appropriate numbers from SFactors
      x[N+1-(i*skip)] = 3*w[i*skip] - 4*w[(i+1)*skip]; // change 3, 4 to appropriate numbers from SFactors
    }
  } else {
    // just brute-force multiply
    SlowUN(x,y,w,S,N,skip);
  }
}

int SlowSN(double *x, double *y, double *w, double *S, int N, int skip){
  int i,j;
  double **SN;

  SN = make_matrix(N-1, N-1);
  for(i=1;i<=N-1;i++){
    for(j=1;j<=N-1;j++){
      SN[i][j] = sin(((double)i*(double)j*M_PI)/(double)N);
    }
  }

  x = mv_multiply(SN, y, N-1, N-1, N-1);
  /*
  printf("SN matrix:\n");
  displayMatrix(SN,N-1);
  printf("y:\n");
  displayVector(y,N-1);
  printf("x:\n");
  */
  displayVector(x,N-1);
  return(0);
}

int SlowTN(double *x, double *y, double *w, double *S, int N, int skip){
  int i,j;
  double **TN;

  TN = make_matrix(N,N);
  for(i=1;i<=N;i++){
    for(j=1;j<=N;j++){
      TN[i][j] = sin(((2.0*(double)i-1)*(double)j*M_PI)/(2.0*(double)N));
    }
  }

  x = mv_multiply(TN,y,N,N,N);
  printf("TN matrix:\n");
  displayMatrix(TN,N);
  printf("y:\n");
  displayVector(y,N);
  printf("x:\n");
  displayVector(x,N);
  return(0);
}

int SlowUN(double *x, double *y, double *w, double *S, int N, int skip){
  int i,j;
  double **UN;

  UN = make_matrix(N,N);
  for(i=1;i<=N;i++){
    for(j=1;j<=N;j++){
      UN[i][j] = sin(((2.0*(double)i-1)*(2.0*(double)j-1)*M_PI)/(4.0*(double)N));
    }
  }

  x = mv_multiply(UN,y,N,N,N);

  printf("UN matrix:\n");
  displayMatrix(UN,N);
  printf("y:\n");
  displayVector(y,N);
  printf("x:\n");
  displayVector(x,N);

  return(0);
}

double **make_matrix(int NR, int NC){ // from lecture notes
	double **M;
	int i, j, n;
	M = (double **)malloc((NR+1)*sizeof(double*));
	M[0] = (double *)malloc((NR+1)*(NC+1)*sizeof(double));
	for(n = 1; n <= NR; n++) M[n] = M[n-1] + NC+1;
	for(i = 0; i <= NR; i++){
		for(j = 0; j <= NC; j++){
		  M[i][j] = (double)i;
		}
	}
	return(M);
}

double **matrix_multiply(double **M1, double **M2, int n1, int m1, int n2, int m2){
  double **ans;
  int i,j,k;
  // multiply two matrices, first n1xm1, second n2xm2
  // returns n1xm2 matrix product
  // first check that the matrix dimensions agree

  // we need that n1 = m2
  if(n1 != m2){
    printf("matrix dimensions do not agree\n");
    exit(0);
  }

  // create result matrix
  ans = make_matrix(n1, m2);

  // if the dimensions agree we can continue
  // three-loop structure, can reorder for efficiency? can parallelise?

  for(i=0;i<n1;i++){
    for(j=0;j<m2;j++){
      for(k=0;k<m1;k++){
	ans[i][j] += M1[i][k]*M2[k][j];
      }
    }
  }
  return(ans);
}

double *mv_multiply(double **M, double *V, int m, int n, int k){
  double *ans;
  int i,j;

  //check dimensions are correct
  if(n!=k){
    printf("matrix dimensions do not agree\n");
    exit(0);
  }

  ans = (double*)malloc(n*sizeof(double));
  for(i=1;i<=m;i++){
    for(j=1;j<=n;j++){
      ans[i] += M[i][j]*V[j];
    }
  }
  return(ans);
}


void displayMatrix(double ** M, int len){

	int i, j;
	for(i = 1; i <= len; i++){
		for(j = 1; j <= len; j++){
			printf("%3.3g\t", M[i][j]);
		}
	printf("\n");
	}
}

void displayVector(double *V, int len){
  int i;

  for(i=1;i<=len;i++){
    printf("%5.5g\n", V[i]);
  }
}
